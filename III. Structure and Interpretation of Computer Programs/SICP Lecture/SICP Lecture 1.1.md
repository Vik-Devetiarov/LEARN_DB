# SICP LECTURE 1.1

## Введение

Механизмы комбинации простых понятий в сложные:

  1. Элементарные выражения;
  2. Средства комбинирования;
  3. Средства абстракции.

Два типа объектов:

  1. Данные;
  2. Процедуры.

## 1.1.1 Выражения

Выражения (expression) > интерпретатор > вычисления (evaluation).

Простейшее выражение - число.

(+ 5 5) - комбинация (combination):

- "+" - оператор (operator);
- "5" и "5" - операнд (operand).

Значение операнда - аргумент (argument)

Префиксная нотация (prefix notation) - соглашение по которому оператор ставится слева от операндов.

Преимущества префиксной нотации:

  1. Распространяется на произвольное количество аргументов;
  2. Естественным образом расширяется, позволяя комбинациям вкладываться (nest) друг в друга.

Красивая печать (pretty printing) - правила форматирования.
Цикл чтение-вычисление-печать (read-eval-print loop)

## 1.1.2 Имена и окружение

Переменная (variable) - значением (value) является объект.

Имена даются применяя define:

```Scheme
(define size 2)
```

Связали значение 2 с именем "size".

После этого можем указывать на значение 2 с помощью имени:

```Scheme
size

2
````

```Scheme
(* 5 size)

10
```

Слово define - простейшее средство асбтракции, поскольку позволяет нам использовать простые имена для обозначения результатов сложных операций.

```Scheme
(define pi 3.14159)
```

```Scheme
(define radius 10)

(* pi (* radius radius))

314.159
```

```Scheme
(define circumference (* 2 pi radius))

circumference

62.8318
```

Интерпритатор имеет память имя-объект. Эта память называется окружением (environment), а точнее глобальным окружением (global environment).

## 1.1.3 Вычисление комбинаций

Чтобы вычислить комбинацию, требуется:

  1. Вычислить все подвыражения;
  2. Применить процедуру, которая является значением самого левого подвыражения (оператора) к аргументам - значениям остальных подвыражений (операндов).

Правило вычисления рекурсивно (recursive). Это означает, что в качестве одного из шагов оно включает применение того же самого правила.

Накопление по древу (tree accumulation) - правило вычисления "распространить значение наверх".

Специальные формы (special forms) - например define.

## 1.1.4 Составные процедуры

Определение процедуры (procedure definition) - метод абстракции, с помощью которого составной оперпции можно дать имя и затем ссылаться на нее как на единое целое.

Возведение в квадрат:

```Scheme
(define (square x) (* x x))
```

Составная процедура (compound procedure):

```Scheme
(define ('имя' 'формальные параметры') 'тело')
```

"Имя" - символ, с которым нужно связать определение процедуры.

"Формальные параметры" - имена в теле процедуры, использующиеся для отсылки к соответствующим аргументам процедуры.

"Тело" - выражение, которое вычисляет результат применения процедуры.

```Scheme
(square 21)
441

(square (+ 2 5))
49

(square (square 3))
81
```

x² + y²

```Scheme
(+ (square x) (square y))

(define (sum-of-squares x y)
  (+ (square x) (square y)))

(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))

(f 5)
136
```

## 1.1.5 Подстановочная модель применения процедуры

Чтобы применить составную процедуру к аргументам, требуется вычислить тело процедуры, заменив каждый формальный параметр соответствующими аргументами. Это подстановочная модель (substitution model).

Два вида вычислений:

1. Нормальный порядок вычислений (normal-order evaluation);
2. Аппликативный порядок вычислений (applicative-order evaluation).

## 1.1.6 Условные выражения и предикаты

Разбор случаев (case analysis).

cond - от conditional (условный).

|x| = x, если x > 0;
      0, если x = 0;
      -x, если x < 0.

```Scheme
(define (abs)
    (cond ((> x 0) x)
          ((= x 0) 0)
          ((< x 0) (- x))))
```

Общая форма условного выражения:

```Scheme
(cond (<p1> <e1>)
      (<p2> <e2>)
      .
      .
      (<pn> <en>))
```

Пары `(<pn> <en>)` - ветви (clauses);
`<pn>` - предикат (predicate) - выражение, значение которого интерпретируется как истина или ложь.

```Scheme
(define (abs x)
    (cond ((< x 0) (- x))
          (else x)))
```

```Scheme
(define (abs x)
    (if (< x 0)
        (- x)
        x))
```

`else` - специальный символ, который в заключительной ветви `cond` можно использовать на месте `<p>`;

`if` - особая форма - можно использовать когда есть рвоно два возхможных исхода:

`if <p> <e> <альтернатива>`

Составные предикаты:

1. `(and <e1> . . . <en>)` - вычисляет слева направо. Если какое-нибудь из `<e>` дает ложное значение? значит все оно - ложь (#f), и остальные `<e>` не вычисляются. Если все `<e>` истина (#t), значением `and` будет значене последнего из них;
2. `(or <e1> . . . <en>)` - вычисляет слева направо. Если какое-либо `<e>` истина (#t), то возвращает его результат, а остальные не вычисляются. Если все `<e>` ложь (#f), то значение ложь (#f);
3. `(not <e>)` - not истина (#t), если `<e>` ложь (#f) и наоборот.

5 < x < 10:

```Scheme
(and (> 5 x) (< x 10))
```

```Scheme
(define (>= x y)
    (or (> x y) (= x y)))
```

```Scheme
(define (>= x y)
    (not (< x y)))
```

## 1.1.7 Вычисление квадратного корня методом Ньютона

Определение функции "квадратный корень":

Корень из x = такое y, что y >= 0 и y * y = x

```Scheme
(define (sqrt x)
  (the y (and (>= y 0)
              (= (square y) x))))

Такое не сработает.
```

В математике декларативные (что такое) описания, в информатике императивные (как).

```Scheme
(define (square x) (* x x))

(define (abs x)
  (if (>= x 0) x
      (- x)))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))

(define (average x y)
  (/ (+ x y) 2))

(define (improve guess x)
  (average guess (/ x guess)))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (sqrt x)
  (sqrt-iter 1.0 x))

(sqrt 2)
```

## 1.1.8 Процедуры как абстракции типа "черный ящик"

Определяя процедуру `good-enough?` с помощью `square` мы можем рассматривать процедуру `square` как "черный ящик". В этот момент нас не интересует, как она вычисляет свой результат, - важно только то, что она способна вычислить квадрат. В этот момет `square` становится процедурной абстракцией (procedural abstraction)

```Scheme
(define (square x) (* x x))

(define (square x)
  (exp (double (log x))))

(define (double x) (+ x x))
```

Локальные имена:

```Scheme
(define (square x) (* x x))

(define (square y) (* y y))
```

Имена параметров должны быть локальными в теле процедуры.

Связанная процедура (bound variable) - определение процедуры связывает (binds) свои формальные параметры.

Если переменная не связана, мы говорим, что она свободна (free).

Множество выражений, для которых связывание определяет имя, называется областью действия (scope) этого имени.

Внутренние определения и блочная структура (block structure):

Лексическая форма действия (lexical scoping) переменных.

```Scheme
(define (square x)
  (* x x))

(define (abs x)
  (if (>= x 0)
      x
      (- x)))

(define (average x y)
  (/ (+ x y) 2))

(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))

(sqrt 2)
```

Внутренние определения должны быть в начале тела процедуры.
